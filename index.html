<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Certify</title>
        <link
            href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap"
            rel="stylesheet"
        />
        <style>
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                padding: 0;
                font-family: "Roboto", sans-serif;
                background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
                color: #333;
            }
            .container {
                max-width: 960px;
                margin: 40px auto;
                background: #fff;
                border-radius: 8px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
                padding: 30px;
            }
            h1 {
                text-align: center;
                margin-bottom: 20px;
                font-weight: 700;
                color: #444;
            }
            .input-group {
                margin-bottom: 20px;
            }
            label {
                display: block;
                margin-bottom: 8px;
                font-weight: 500;
            }
            input[type="file"],
            input[type="text"],
            input[type="number"] {
                width: 100%;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 16px;
            }
            input[type="checkbox"] {
                margin-right: 5px;
                transform: scale(1.2);
            }
            #instructions {
                font-size: 14px;
                color: #777;
                margin-bottom: 15px;
            }
            #image-container {
                position: relative;
                margin: 20px 0;
                text-align: center;
            }
            #certificate-canvas {
                width: 100%;
                max-width: 100%;
                border: 2px solid #ddd;
                border-radius: 4px;
            }
            #overlay {
                position: absolute;
                border: 2px dashed #e74c3c;
                pointer-events: none;
                display: none;
            }
            button {
                background: #3498db;
                color: #fff;
                border: none;
                padding: 15px 30px;
                font-size: 16px;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.3s ease;
                display: block;
                margin: 20px auto 0 auto;
            }
            button:hover {
                background: #2980b9;
            }
            footer {
                position: absolute;
                top: 0;
                right: 0;
                text-align: right;
                margin: 10px;
                font-size: 14px;
                color: #777;
            }
            /* Modal styling for new/edit region */
            .modal {
                display: none;
                position: fixed;
                z-index: 1000;
                padding-top: 100px;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.4);
            }
            .modal-content {
                background-color: #fefefe;
                margin: auto;
                padding: 20px;
                border: 1px solid #888;
                width: 80%;
                max-width: 400px;
                border-radius: 8px;
                text-align: center;
            }
            .modal-content input,
            .modal-content select {
                margin-bottom: 15px;
            }
            .modal-content .btn-group {
                margin-top: 10px;
            }
            .resize-handle {
                position: absolute;
                width: 10px;
                height: 10px;
                background: #fff;
                border: 1px solid #e74c3c;
                z-index: 10;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Certify: Bulk Certificate Generator</h1>
            <div class="input-group">
                <label for="imageUpload">Upload Certificate Image:</label>
                <input type="file" id="imageUpload" accept="image/*" />
            </div>
            <div class="input-group">
                <label for="excelUpload">Upload Excel File:</label>
                <input type="file" id="excelUpload" accept=".xlsx, .xls" />
            </div>
            <div id="instructions">
                Draw a region on the certificate image to define where a label
                should appear. After releasing the mouse, a dialog will prompt
                you for the label, font size, font family, and a title-case
                option. You can add multiple regions.
                <br /><br />
                • To move/resize a region, click and drag (edges to resize,
                inside to move). • Double-click a region to edit or delete it.
            </div>
            <div id="image-container">
                <canvas id="certificate-canvas"></canvas>
                <div id="overlay"></div>
            </div>
            <button id="submitBtn">Submit &amp; Generate Certificates</button>
        </div>
        <footer>
            <a
                href="https://github.com/akhilt2/Certify"
                target="_blank"
                style="text-decoration: none"
                title="Source Code"
                ><svg height="50" viewBox="0 0 24 24" alt="Github Logo">
                    <path
                        d="M12 1C5.9225 1 1 5.9225 1 12C1 16.8675 4.14875 20.9787 8.52125 22.4362C9.07125 22.5325 9.2775 22.2025 9.2775 21.9137C9.2775 21.6525 9.26375 20.7862 9.26375 19.865C6.5 20.3737 5.785 19.1912 5.565 18.5725C5.44125 18.2562 4.905 17.28 4.4375 17.0187C4.0525 16.8125 3.5025 16.3037 4.42375 16.29C5.29 16.2762 5.90875 17.0875 6.115 17.4175C7.105 19.0812 8.68625 18.6137 9.31875 18.325C9.415 17.61 9.70375 17.1287 10.02 16.8537C7.5725 16.5787 5.015 15.63 5.015 11.4225C5.015 10.2262 5.44125 9.23625 6.1425 8.46625C6.0325 8.19125 5.6475 7.06375 6.2525 5.55125C6.2525 5.55125 7.17375 5.2625 9.2775 6.67875C10.1575 6.43125 11.0925 6.3075 12.0275 6.3075C12.9625 6.3075 13.8975 6.43125 14.7775 6.67875C16.8813 5.24875 17.8025 5.55125 17.8025 5.55125C18.4075 7.06375 18.0225 8.19125 17.9125 8.46625C18.6138 9.23625 19.04 10.2125 19.04 11.4225C19.04 15.6437 16.4688 16.5787 14.0213 16.8537C14.42 17.1975 14.7638 17.8575 14.7638 18.8887C14.7638 20.36 14.75 21.5425 14.75 21.9137C14.75 22.2025 14.9563 22.5462 15.5063 22.4362C19.8513 20.9787 23 16.8537 23 12C23 5.9225 18.0775 1 12 1Z"
                    ></path></svg
            ></a>
        </footer>
        <!-- Modal for new/edit region -->
        <div id="regionModal" class="modal">
            <div class="modal-content">
                <h3 id="modalTitle">New Region</h3>
                <label for="regionLabel">Label:</label>
                <input type="text" id="regionLabel" placeholder="Label name" />
                <div style="margin: 10px 0">
                    <input type="checkbox" id="regionTitleCase" checked />
                    <label for="regionTitleCase" style="display: inline"
                        >Capitalize first letter of each word</label
                    >
                </div>
                <label for="regionFontSize">Font Size (px):</label>
                <input type="number" id="regionFontSize" value="24" />
                <label for="regionFontFamily">Font Family:</label>
                <select id="regionFontFamily">
                    <option value="Brush Script MT, cursive" selected>
                        Brush Script MT
                    </option>
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Georgia">Georgia</option>
                </select>
                <div class="btn-group">
                    <button id="saveRegionBtn">Save</button>
                    <button
                        id="deleteRegionBtn"
                        style="display: none; background: #e74c3c"
                    >
                        Delete
                    </button>
                    <button id="cancelRegionBtn" style="background: #95a5a6">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
        <script>
            // Utility function: Convert string to Title Case
            function toTitleCase(str) {
                return str
                    .split(" ")
                    .map((word) => {
                        return (
                            word.charAt(0).toUpperCase() +
                            word.slice(1).toLowerCase()
                        );
                    })
                    .join(" ");
            }

            // Global variables and settings
            let image = new Image();
            let canvas = document.getElementById("certificate-canvas");
            let ctx = canvas.getContext("2d");
            let overlay = document.getElementById("overlay");
            let selections = []; // Array of regions
            let pendingRegion = null; // For new region drawing
            let activeRegionIndex = null; // For moving/resizing/editing

            // For move/resize handling
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let resizeMode = false;
            let resizeDirection = null; // e.g., "nw", "ne", "sw", "se"
            const resizeThreshold = 10; // pixels

            // Modal elements
            const regionModal = document.getElementById("regionModal");
            const modalTitle = document.getElementById("modalTitle");
            const regionLabelInput = document.getElementById("regionLabel");
            const regionTitleCaseInput =
                document.getElementById("regionTitleCase");
            const regionFontSizeInput =
                document.getElementById("regionFontSize");
            const regionFontFamilySelect =
                document.getElementById("regionFontFamily");
            const saveRegionBtn = document.getElementById("saveRegionBtn");
            const deleteRegionBtn = document.getElementById("deleteRegionBtn");
            const cancelRegionBtn = document.getElementById("cancelRegionBtn");

            // Redraw canvas (draw image and regions)
            function redrawCanvas() {
                if (!image.src) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(image, 0, 0);
                selections.forEach((sel) => {
                    ctx.strokeStyle = "#e74c3c";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sel.x, sel.y, sel.width, sel.height);
                    ctx.fillStyle = "rgba(231, 76, 60, 0.2)";
                    ctx.fillRect(sel.x, sel.y, sel.width, sel.height);
                    ctx.font = "bold " + sel.fontSize + "px " + sel.fontFamily;
                    ctx.fillStyle = "#e74c3c";
                    ctx.textBaseline = "middle";
                    ctx.textAlign = "center";
                    // Use our updated wrapped text function to center the label vertically
                    drawWrappedText(
                        ctx,
                        sel.label,
                        sel.x,
                        sel.y,
                        sel.width,
                        sel.height,
                        30,
                    );
                });
            }

            // Load image
            document
                .getElementById("imageUpload")
                .addEventListener("change", (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        image.onload = function () {
                            canvas.width = image.width;
                            canvas.height = image.height;
                            redrawCanvas();
                            const rect = canvas.getBoundingClientRect();
                            overlay.style.width = rect.width + "px";
                            overlay.style.height = rect.height + "px";
                            overlay.style.left = "0px";
                            overlay.style.top = "0px";
                        };
                        image.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                });

            // Convert mouse event to internal canvas coordinates
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                let scaleX = canvas.width / rect.width;
                let scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY,
                };
            }

            // Convert internal coordinates to display coordinates
            function toDisplay(val, axis = "x") {
                const rect = canvas.getBoundingClientRect();
                return axis === "x"
                    ? val * (rect.width / canvas.width)
                    : val * (rect.height / canvas.height);
            }

            // New region drawing, moving, and resizing
            let isDrawingNew = false;
            canvas.addEventListener("mousedown", function (e) {
                const pos = getMousePos(e);
                // Check if click is in an existing region for move/resize/edit
                let hitIndex = null;
                selections.forEach((sel, idx) => {
                    if (
                        pos.x >= sel.x &&
                        pos.x <= sel.x + sel.width &&
                        pos.y >= sel.y &&
                        pos.y <= sel.y + sel.height
                    ) {
                        hitIndex = idx;
                    }
                });
                if (hitIndex !== null) {
                    // Determine if near border (for resize) or inside (for move)
                    const sel = selections[hitIndex];
                    let onLeft = Math.abs(pos.x - sel.x) < resizeThreshold;
                    let onRight =
                        Math.abs(pos.x - (sel.x + sel.width)) < resizeThreshold;
                    let onTop = Math.abs(pos.y - sel.y) < resizeThreshold;
                    let onBottom =
                        Math.abs(pos.y - (sel.y + sel.height)) <
                        resizeThreshold;
                    if (onLeft || onRight || onTop || onBottom) {
                        activeRegionIndex = hitIndex;
                        resizeMode = true;
                        if (onLeft && onTop) resizeDirection = "nw";
                        else if (onRight && onTop) resizeDirection = "ne";
                        else if (onLeft && onBottom) resizeDirection = "sw";
                        else if (onRight && onBottom) resizeDirection = "se";
                        else {
                            resizeDirection = onLeft
                                ? "w"
                                : onRight
                                  ? "e"
                                  : onTop
                                    ? "n"
                                    : onBottom
                                      ? "s"
                                      : "";
                        }
                    } else {
                        activeRegionIndex = hitIndex;
                        resizeMode = false;
                        dragOffset.x = pos.x - selections[hitIndex].x;
                        dragOffset.y = pos.y - selections[hitIndex].y;
                    }
                    isDragging = true;
                } else {
                    isDrawingNew = true;
                    pendingRegion = { x: pos.x, y: pos.y, width: 0, height: 0 };
                    isDragging = true;
                }
            });

            canvas.addEventListener("mousemove", function (e) {
                const pos = getMousePos(e);
                if (isDrawingNew && isDragging) {
                    pendingRegion.width = Math.abs(pos.x - pendingRegion.x);
                    pendingRegion.height = Math.abs(pos.y - pendingRegion.y);
                    pendingRegion.x = Math.min(pos.x, pendingRegion.x);
                    pendingRegion.y = Math.min(pos.y, pendingRegion.y);
                    overlay.style.display = "block";
                    overlay.style.left = toDisplay(pendingRegion.x) + "px";
                    overlay.style.top = toDisplay(pendingRegion.y, "y") + "px";
                    overlay.style.width = toDisplay(pendingRegion.width) + "px";
                    overlay.style.height =
                        toDisplay(pendingRegion.height, "y") + "px";
                } else if (isDragging && activeRegionIndex !== null) {
                    if (resizeMode) {
                        let sel = selections[activeRegionIndex];
                        if (resizeDirection.includes("n")) {
                            let diff = pos.y - sel.y;
                            sel.y = pos.y;
                            sel.height -= diff;
                        }
                        if (resizeDirection.includes("s")) {
                            sel.height = pos.y - sel.y;
                        }
                        if (resizeDirection.includes("w")) {
                            let diff = pos.x - sel.x;
                            sel.x = pos.x;
                            sel.width -= diff;
                        }
                        if (resizeDirection.includes("e")) {
                            sel.width = pos.x - sel.x;
                        }
                        redrawCanvas();
                    } else {
                        let sel = selections[activeRegionIndex];
                        sel.x = pos.x - dragOffset.x;
                        sel.y = pos.y - dragOffset.y;
                        redrawCanvas();
                    }
                }
            });

            canvas.addEventListener("mouseup", function (e) {
                isDragging = false;
                if (isDrawingNew) {
                    isDrawingNew = false;
                    overlay.style.display = "none";
                    openRegionModal("new", null, pendingRegion);
                    pendingRegion = null;
                }
                activeRegionIndex = null;
                resizeMode = false;
            });

            canvas.addEventListener("dblclick", function (e) {
                const pos = getMousePos(e);
                let hitIndex = null;
                selections.forEach((sel, idx) => {
                    if (
                        pos.x >= sel.x &&
                        pos.x <= sel.x + sel.width &&
                        pos.y >= sel.y &&
                        pos.y <= sel.y + sel.height
                    ) {
                        hitIndex = idx;
                    }
                });
                if (hitIndex !== null) {
                    openRegionModal("edit", hitIndex, selections[hitIndex]);
                }
            });

            // Open modal for new/edit region. Mode can be "new" or "edit"
            function openRegionModal(mode, index, regionData) {
                regionModal.style.display = "block";
                if (mode === "new") {
                    modalTitle.textContent = "New Region";
                    regionLabelInput.value = "";
                    regionTitleCaseInput.checked = true;
                    regionFontSizeInput.value = 24;
                    // Default font is Brush Script MT
                    regionFontFamilySelect.value = "Brush Script MT, cursive";
                    deleteRegionBtn.style.display = "none";
                    saveRegionBtn.onclick = function () {
                        let label = regionLabelInput.value.trim();
                        if (label === "") {
                            alert("Please enter a label.");
                            return;
                        }
                        let newRegion = {
                            x: regionData.x,
                            y: regionData.y,
                            width: regionData.width,
                            height: regionData.height,
                            label: label,
                            titleCase: regionTitleCaseInput.checked,
                            fontSize: Number(regionFontSizeInput.value) || 24,
                            fontFamily: regionFontFamilySelect.value,
                        };
                        selections.push(newRegion);
                        regionModal.style.display = "none";
                        redrawCanvas();
                    };
                } else if (mode === "edit") {
                    modalTitle.textContent = "Edit Region";
                    deleteRegionBtn.style.display = "inline-block";
                    regionLabelInput.value = regionData.label;
                    regionTitleCaseInput.checked = regionData.titleCase;
                    regionFontSizeInput.value = regionData.fontSize;
                    regionFontFamilySelect.value = regionData.fontFamily;
                    saveRegionBtn.onclick = function () {
                        let label = regionLabelInput.value.trim();
                        if (label === "") {
                            alert("Please enter a label.");
                            return;
                        }
                        selections[index].label = label;
                        selections[index].titleCase =
                            regionTitleCaseInput.checked;
                        selections[index].fontSize =
                            Number(regionFontSizeInput.value) || 24;
                        selections[index].fontFamily =
                            regionFontFamilySelect.value;
                        regionModal.style.display = "none";
                        redrawCanvas();
                    };
                    deleteRegionBtn.onclick = function () {
                        if (
                            confirm(
                                "Are you sure you want to delete this region?",
                            )
                        ) {
                            selections.splice(index, 1);
                            regionModal.style.display = "none";
                            redrawCanvas();
                        }
                    };
                }
            }

            cancelRegionBtn.onclick = function () {
                regionModal.style.display = "none";
            };

            window.onclick = function (event) {
                if (event.target == regionModal) {
                    regionModal.style.display = "none";
                }
            };

            // Updated wrapped text function that vertically centers text within the region.
            function drawWrappedText(
                ctx,
                text,
                x,
                y,
                maxWidth,
                regionHeight,
                lineHeight,
            ) {
                let words = text.split(" ");
                let lines = [];
                let currentLine = "";
                for (let n = 0; n < words.length; n++) {
                    let testLine = currentLine + words[n] + " ";
                    let metrics = ctx.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && currentLine !== "") {
                        lines.push(currentLine.trim());
                        currentLine = words[n] + " ";
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) {
                    lines.push(currentLine.trim());
                }
                let totalTextHeight = lines.length * lineHeight;
                let startY =
                    y + (regionHeight - totalTextHeight) / 2 + lineHeight / 2;
                for (let i = 0; i < lines.length; i++) {
                    ctx.fillText(
                        lines[i],
                        x + maxWidth / 2,
                        startY + i * lineHeight,
                    );
                }
            }

            // Certificate generation
            document
                .getElementById("submitBtn")
                .addEventListener("click", function () {
                    const excelInput =
                        document.getElementById("excelUpload").files[0];
                    if (!image.src) {
                        alert("Please upload a certificate image.");
                        return;
                    }
                    if (!excelInput) {
                        alert("Please upload an Excel file.");
                        return;
                    }
                    if (selections.length === 0) {
                        alert(
                            "Please draw at least one region with an associated label.",
                        );
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const data = event.target.result;
                        let workbook = XLSX.read(data, { type: "binary" });
                        let allRows = [];
                        workbook.SheetNames.forEach(function (sheetName) {
                            const sheet = workbook.Sheets[sheetName];
                            const sheetData = XLSX.utils.sheet_to_json(sheet, {
                                header: 1,
                            });
                            if (sheetData.length === 0) return;
                            let header = sheetData[0].map((h) =>
                                typeof h === "string" ? h.toLowerCase() : "",
                            );
                            for (let i = 1; i < sheetData.length; i++) {
                                let rowObj = {};
                                let row = sheetData[i];
                                header.forEach((colName, idx) => {
                                    if (colName) {
                                        if (
                                            row[idx] !== undefined &&
                                            row[idx] !== null
                                        ) {
                                            let current = rowObj[colName] || "";
                                            rowObj[colName] = current
                                                ? current + " " + row[idx]
                                                : row[idx];
                                        }
                                    }
                                });
                                allRows.push(rowObj);
                            }
                        });
                        if (allRows.length === 0) {
                            alert("No data found in the Excel file.");
                            return;
                        }
                        let zip = new JSZip();
                        let certPromises = allRows.map(
                            function (row, rowIndex) {
                                return new Promise(function (resolve) {
                                    let offCanvas =
                                        document.createElement("canvas");
                                    offCanvas.width = image.width;
                                    offCanvas.height = image.height;
                                    let offCtx = offCanvas.getContext("2d");
                                    offCtx.drawImage(image, 0, 0);
                                    selections.forEach((sel) => {
                                        let key = sel.label.toLowerCase();
                                        let text = row[key]
                                            ? String(row[key]).trim()
                                            : "";
                                        if (text !== "") {
                                            if (sel.titleCase) {
                                                text = toTitleCase(text);
                                            }
                                            offCtx.font =
                                                "bold " +
                                                sel.fontSize +
                                                "px " +
                                                sel.fontFamily;
                                            offCtx.fillStyle = "#333";
                                            offCtx.textBaseline = "middle";
                                            offCtx.textAlign = "center";
                                            drawWrappedText(
                                                offCtx,
                                                text,
                                                sel.x,
                                                sel.y,
                                                sel.width,
                                                sel.height,
                                                30,
                                            );
                                        }
                                    });
                                    offCanvas.toBlob(function (blob) {
                                        zip.file(
                                            "certificate_" +
                                                (rowIndex + 1) +
                                                ".png",
                                            blob,
                                        );
                                        resolve();
                                    });
                                });
                            },
                        );
                        Promise.all(certPromises).then(function () {
                            zip.generateAsync({ type: "blob" }).then(
                                function (content) {
                                    saveAs(content, "certificates.zip");
                                },
                            );
                        });
                    };
                    reader.readAsBinaryString(excelInput);
                });
        </script>
    </body>
</html>
